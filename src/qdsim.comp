component qdsim "EMC HAL component to simulate the Dana Summit Quickdraw tool changer";

pin in bit tool_in_command "Tool-In command to the tool changer. Moves the arm to the spindle";
pin in bit tool_out_command "Tool-Out command to the tool changer. Moves the arm to the carousel";
pin in bit carousel_cw_command "Turret CW command to the tool changer. Moves the carousel clockwise";
pin in bit carousel_ccw_command "Turret CCW command to the tool changer. Moves the carousel counterclockwise";
pin in bit carousel_home_command "Turret Home command to the tool changer.";

pin out bit qd_complete "Reset signal from the Quickdraw Tool Changer that the current operation is complete";
pin out bit claw_open "Indication that the claw is being held in the opon position.";

param rw unsigned carousel_home_time=10 "Time in seconds for the carousel to home.";
param rw unsigned carousel_move_time=1.2 "Time in seconds for the carousel to move one tool position.";
param rw unsigned arm_move_time=7.0 "Time in seconds for moving a tool from the carousel to or from the spindle.";
param rw unsigned complete_time=100 "Time in milliseconds for complete to stay TRUE";
param rw unsigned claw_open_time=200 "Time in milliseconds for the claw open indication after a tool in or tool out is complete";

description """
qdtoolchange simulates the Dana Summit Quickdraw tool changer.o

""";

license "GPL";
author "K. Cunningham";
option singleton yes;
option extra_setup yes;
function _ ;
;;

// State names defined
typedef enum {
	STATE_IDLE, // 0
	STATE_INIT, // 1
	STATE_TOOL_OUT, // 2
	STATE_TOOL_IN, // 3
	STATE_CAROUSEL_MOVE, // 4
	STATE_CAROUSEL_HOME, // 5
	STATE_WAIT_CLAW_OPEN, // 6
	STATE_WAIT_COMPL_FALSE, // 7
	STATE_ERROR // 8
} States;

#define STATE_STACK_DEPTH 10
static int state_stack[STATE_STACK_DEPTH];
static int state_index;
static short cur_state;
static short prev_state;
static float timer;
static float claw_timer;
static bool completed; // Debounced state of the complete input pin
static int new_tool_in;
static int move_cw; // Move the carousel CW
static bool homed_flag; // Whether the tool changer carousel has been homed.
static bool is_on; // Current state of machine_on
static int cur_pocket_no; // The tool pocket currently in position. 0 if not homed
static int error_output; // ORed error conditions
static bool done;

static bool state_changed;
static bool was_completed;
static bool was_on; // Previous state of pgm_running

FUNCTION(_) {
	/* Maintain the timer */
	timer += period;	
	state_changed = (cur_state != prev_state);
	if(state_changed) {
		prev_state = cur_state;
	} 

	/* On entering each state other than IDLE, check for AUTO mode. If not, it's an error. */
	switch(cur_state) {
		case STATE_IDLE: // Check tool_change for a new tool request.
			if(state_changed) {
				/* Since cur_state is initialized to STATE_IDLE and at startup there is no state tool_change, 
				 *  we must have come here from another state. If it wasn't the STATE_ERROR, set done TRUE */
				if(!was_error)
					done = TRUE;
			} else if(tool_change && !done) {
				/* Latch the new tool inputs. */
				new_tool_in = tool_num;
				if(new_tool_in < 0 || new_tool_in > changer_capacity) {
					error_output = ERROR_INVALID_NEW_TOOL;
					cur_state = STATE_ERROR;
				} else {
					/* All OK. Continue */
					cur_state = STATE_INIT;
				}
			} else if(!tool_change && done) {
				/* Release the ack only when the tool_change goes FALSE. */
				done = FALSE;
			}
			break; // STATE_IDLE

		case STATE_MOVE_ARM:
			/* Check state of hardware and take action if needed. Otherwise, start the tool change.
			 * If not homed, we need to do that first. */
			if(!qd_auto_deb) {
				 error_output = ERROR_NOT_AUTO_MODE;
				 cur_state = STATE_ERROR;
			} else if(completed) {
				/* completed is TRUE. We must wait for it to go FALSE before initiating a movement. */
				enqueue_state(STATE_INIT);
				cur_state = STATE_WAIT_COMPL_FALSE;
			} else if(!claw_open_deb) {
				/* The claw-open signal is not present. We can't proceed without that. Probably no
				 *  air line connected. */
				error_output = ERROR_NOT_CLAW_OPEN;
				cur_state = STATE_ERROR;
			} else {
				if(new_tool_in) {
					/* Only put a new tool in if asked to. Zero for new_tool_in means just 
					 *  take the old tool out. */
					enqueue_state(STATE_TOOL_IN);
					enqueue_state(STATE_CAROUSEL_MOVE);
				}
				if(homed_flag) {
					/* We assume if we're homed the carousel is already in position. So 
					 *  just take the tool out. */
					cur_state = STATE_TOOL_OUT;
				} else {
					/* Not homed. Take the tool out and home it. */
					enqueue_state(STATE_CAROUSEL_HOME);
					cur_state = STATE_TOOL_OUT;
				}
			}
			break; // STATE_INIT

		case STATE_CAROUSEL_MOVE: // Move to new tool position
			if (state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					/*  Start the timer, determine which way and how far to move the carousel, and start the movement. */
					timer = 0;
					if(!new_tool_in || (new_tool_in == cur_pocket_no)) {
						/* No move necessary. */
						cur_state = dequeue_state();
					} else {
						distance = new_tool_in - cur_pocket_no;
						move_cw = ((distance + changer_capacity) % changer_capacity) > (changer_capacity / 2);
						if(move_cw)
							carousel_cw_command = TRUE;
						else
							carousel_ccw_command = TRUE;
					}
				}
			} else if(!completed && was_completed) {
				/* The debounced completed input has just gone FALSE. Reset the timer */
				timer = 0;
			} else if(completed && was_completed) {
				/* Completed is high and was high in the previous cycle. Wait for it to go FALSE, 
				 *  but not past the timeout. We don't use the STATE_WAIT_COMPL_FALSE state since it might
				 *  require a two-level return stack. */
				if(timer >= complete_max_time * NSPERMSEC) {
					error_output = ERROR_QD_COMPLETE_STUCK_HIGH;
					cur_state = STATE_ERROR;
				}
			} else if(completed && !was_completed) {
				/* completed has just gone TRUE. We've moved one tool. Reset the timer,
				 *  update the pocket number, and check if we've gone around the end. */
				timer = 0;
				if(move_cw) {
					// CW movement. Decreasing pocket numbers
					if(--cur_pocket_no < 1)
						cur_pocket_no = changer_capacity;
				} else {
					// CCW movement. Increasing pocket numbers
					if(++cur_pocket_no > changer_capacity)
						cur_pocket_no = 1;
				}
				if(cur_pocket_no == new_tool_in) {
					/* We're done. Turn both directions off to be sure */
					carousel_cw_command = FALSE;
					carousel_ccw_command = FALSE;
					cur_state = dequeue_state();
				}
			} else if(!completed && (timer >= (unsigned long long)carousel_move_timeout * NSPERSEC)) {
				/* completed is still false and has timed out */
				carousel_cw_command = FALSE;
				carousel_ccw_command = FALSE;
				error_output = ERROR_CAROUSEL_MOVE_FAIL;
				cur_state = STATE_ERROR;
			}
			break; // STATE_CAROUSEL_MOVE

		case STATE_CAROUSEL_HOME:
			if(state_changed) {
				if(completed) {
					/* Wait for completed to go FALSE */
					enqueue_state(cur_state);
					cur_state = STATE_WAIT_COMPL_FALSE;
				} else {
					timer = 0;
					carousel_home_command = TRUE;
				}
			} else if(completed) {
				/* Done with homing the carousel. */
				carousel_home_command = FALSE;
				homed_flag = TRUE;
				cur_pocket_no = 1;
				cur_state = dequeue_state();
			} else if(timer >= (unsigned long long)carousel_home_timeout * NSPERSEC) {
				carousel_home_command = FALSE;
				error_output = ERROR_CAROUSEL_HOME_FAIL;
				cur_state = STATE_ERROR;
			}
			break; // STATE_CAROUSEL_HOME
		
	}
	current_state = cur_state;
	current_tool = cur_pocket_no;
	error_code = error_output;
	error_flag = (error_code != 0);
	tool_changed = (done && claw_open_deb);
	is_homed = homed_flag;
	ready = (qd_auto_deb && claw_open_deb && !error_flag);
}

EXTRA_SETUP() {
	state_stack[0] = STATE_IDLE;
	prev_state = cur_state = STATE_IDLE;
	return 0;
}
